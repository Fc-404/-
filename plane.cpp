#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<Windows.h>
#include<time.h>
#include"declaration.h"
//函数声明；

DWORD WINAPI obstacle_move(LPVOID lpParamter);
DWORD WINAPI fire(LPVOID lpParamter);
DWORD WINAPI buff(LPVOID lpParamter);
void obstacle(coordinates*, short, bool);
void get_extend(short, short);
bool crash(short, short, short);
short plane_move();
void game_over();
bool clear_buff(short, short);
//全局变量；
coordinates* fire_head = NULL, * end = NULL;
coordinates* y5, * y2, * y3, * y4;//四块墙；
coordinates Y5,  Y2,  Y3,  Y4;
bool on_off = NULL;//模块状态;
bool o_m = NULL, fi = NULL, bf = NULL;
unsigned short buff_count = NULL;//buff计数；
unsigned short bullet = NULL, score = NULL, life = NULL;//子弹，分数，生命；
unsigned p_timestamp = NULL;

//空军七号模块主函数；
void plane_start() {
	//空军七号地图；
	short p_map[][3] = {
1,1,153,
2,1,153,
3,1,153,
4,1,153,
5,1,153,
6,1,153,
7,1,153,
8,1,153,
9,1,153,
10,1,153,
11,1,153,
12,1,153,
13,1,153,
14,1,153,
15,1,153,
16,1,153,
17,1,153,
18,1,153,
19,1,153,
20,1,153,
21,1,153,
22,1,153,
23,1,153,
24,1,153,
25,1,153,
26,1,153,
27,1,153,
28,1,153,
29,1,153,
30,1,153,
31,1,153,
32,1,153,
33,1,153,
34,1,153,
35,1,153,
36,1,153,
37,1,153,
38,1,153,
39,1,153,
40,1,153,
41,1,153,
42,1,153,
43,1,153,
44,1,153,
45,1,153,
46,1,153,
47,1,153,
48,1,153,
49,1,153,
50,1,17,
51,1,17,
52,1,17,
53,1,17,
54,1,17,
55,1,17,
56,1,17,
57,1,17,
58,1,17,
59,1,17,
60,1,17,
61,1,17,
62,1,17,
63,1,17,
64,1,17,
65,1,17,
66,1,17,
67,1,17,
68,1,17,
69,1,17,
70,1,17,
71,1,17,
72,1,17,
73,1,17,
74,1,17,
75,1,17,
76,1,17,
77,1,17,
78,1,17,
79,1,17,
80,1,17,
81,1,17,
82,1,17,
83,1,17,
84,1,17,
85,1,17,
86,1,17,
87,1,17,
88,1,17,
89,1,17,
90,1,17,
1,2,153,
50,2,153,
90,2,17,
1,3,153,
50,3,153,
90,3,17,
1,4,153,
50,4,153,
90,4,17,
1,5,153,
50,5,153,
55,5,255,
56,5,51,
57,5,51,
58,5,51,
59,5,51,
60,5,51,
61,5,51,
69,5,238,
70,5,238,
71,5,238,
72,5,238,
73,5,238,
76,5,238,
77,5,238,
78,5,238,
79,5,238,
80,5,238,
83,5,238,
84,5,238,
85,5,238,
86,5,238,
87,5,238,
90,5,17,
1,6,153,
50,6,153,
55,6,51,
56,6,255,
57,6,255,
58,6,255,
59,6,255,
60,6,255,
61,6,51,
69,6,238,
73,6,238,
76,6,238,
80,6,238,
83,6,238,
87,6,238,
90,6,17,
1,7,153,
50,7,153,
55,7,51,
56,7,255,
57,7,51,
58,7,51,
59,7,255,
60,7,255,
61,7,51,
65,7,136,
66,7,136,
69,7,238,
73,7,238,
76,7,238,
80,7,238,
83,7,238,
87,7,238,
90,7,17,
1,8,153,
50,8,153,
55,8,51,
56,8,255,
57,8,255,
58,8,255,
59,8,255,
60,8,255,
61,8,51,
65,8,136,
66,8,136,
69,8,238,
73,8,238,
76,8,238,
80,8,238,
83,8,238,
87,8,238,
90,8,17,
1,9,153,
50,9,153,
55,9,51,
56,9,255,
57,9,51,
58,9,255,
59,9,51,
60,9,255,
61,9,51,
69,9,238,
70,9,238,
71,9,238,
72,9,238,
73,9,238,
76,9,238,
77,9,238,
78,9,238,
79,9,238,
80,9,238,
83,9,238,
84,9,238,
85,9,238,
86,9,238,
87,9,238,
90,9,17,
1,10,153,
50,10,153,
55,10,51,
56,10,255,
57,10,255,
58,10,255,
59,10,255,
60,10,255,
61,10,51,
69,10,238,
73,10,238,
76,10,238,
80,10,238,
83,10,238,
87,10,238,
90,10,17,
1,11,153,
50,11,153,
55,11,51,
56,11,255,
57,11,51,
58,11,51,
59,11,51,
60,11,255,
61,11,51,
69,11,238,
73,11,238,
76,11,238,
80,11,238,
83,11,238,
87,11,238,
90,11,17,
1,12,153,
50,12,153,
55,12,51,
56,12,255,
57,12,255,
58,12,255,
59,12,255,
60,12,255,
61,12,51,
65,12,136,
66,12,136,
69,12,238,
73,12,238,
76,12,238,
80,12,238,
83,12,238,
87,12,238,
90,12,17,
1,13,153,
50,13,153,
55,13,51,
56,13,255,
57,13,255,
58,13,255,
59,13,255,
60,13,255,
61,13,51,
65,13,136,
66,13,136,
69,13,238,
73,13,238,
76,13,238,
80,13,238,
83,13,238,
87,13,238,
90,13,17,
1,14,153,
50,14,153,
55,14,51,
56,14,51,
57,14,51,
58,14,51,
59,14,51,
60,14,51,
61,14,51,
69,14,238,
70,14,238,
71,14,238,
72,14,238,
73,14,238,
76,14,238,
77,14,238,
78,14,238,
79,14,238,
80,14,238,
83,14,238,
84,14,238,
85,14,238,
86,14,238,
87,14,238,
90,14,17,
1,15,153,
50,15,153,
90,15,17,
1,16,153,
50,16,153,
90,16,17,
1,17,153,
50,17,153,
90,17,17,
1,18,153,
50,18,153,
58,18,34,
69,18,238,
70,18,238,
71,18,238,
72,18,238,
73,18,238,
76,18,238,
77,18,238,
78,18,238,
79,18,238,
80,18,238,
83,18,238,
84,18,238,
85,18,238,
86,18,238,
87,18,238,
90,18,17,
1,19,153,
50,19,153,
57,19,34,
58,19,34,
59,19,34,
69,19,238,
73,19,238,
76,19,238,
80,19,238,
83,19,238,
87,19,238,
90,19,17,
1,20,153,
50,20,153,
57,20,34,
58,20,34,
59,20,34,
65,20,136,
66,20,136,
69,20,238,
73,20,238,
76,20,238,
80,20,238,
83,20,238,
87,20,238,
90,20,17,
1,21,153,
50,21,153,
56,21,34,
57,21,255,
58,21,255,
59,21,34,
60,21,34,
65,21,136,
66,21,136,
69,21,238,
73,21,238,
76,21,238,
80,21,238,
83,21,238,
87,21,238,
90,21,17,
1,22,153,
50,22,153,
56,22,34,
57,22,255,
58,22,34,
59,22,34,
60,22,34,
69,22,238,
70,22,238,
71,22,238,
72,22,238,
73,22,238,
76,22,238,
77,22,238,
78,22,238,
79,22,238,
80,22,238,
83,22,238,
84,22,238,
85,22,238,
86,22,238,
87,22,238,
90,22,17,
1,23,153,
50,23,153,
56,23,34,
57,23,34,
58,23,34,
59,23,34,
60,23,34,
69,23,238,
73,23,238,
76,23,238,
80,23,238,
83,23,238,
87,23,238,
90,23,17,
1,24,153,
50,24,153,
56,24,34,
57,24,34,
58,24,34,
59,24,34,
60,24,34,
69,24,238,
73,24,238,
76,24,238,
80,24,238,
83,24,238,
87,24,238,
90,24,17,
1,25,153,
50,25,153,
56,25,34,
57,25,34,
58,25,34,
59,25,34,
60,25,34,
65,25,136,
66,25,136,
69,25,238,
73,25,238,
76,25,238,
80,25,238,
83,25,238,
87,25,238,
90,25,17,
1,26,153,
50,26,153,
56,26,34,
57,26,34,
58,26,34,
59,26,34,
60,26,34,
65,26,136,
66,26,136,
69,26,238,
73,26,238,
76,26,238,
80,26,238,
83,26,238,
87,26,238,
90,26,17,
1,27,153,
50,27,153,
56,27,34,
57,27,34,
58,27,34,
59,27,34,
60,27,34,
69,27,238,
70,27,238,
71,27,238,
72,27,238,
73,27,238,
76,27,238,
77,27,238,
78,27,238,
79,27,238,
80,27,238,
83,27,238,
84,27,238,
85,27,238,
86,27,238,
87,27,238,
90,27,17,
1,28,153,
50,28,153,
90,28,17,
1,29,153,
50,29,153,
90,29,17,
1,30,153,
50,30,153,
90,30,17,
1,31,153,
50,31,153,
54,31,204,
55,31,204,
60,31,204,
61,31,204,
69,31,238,
70,31,238,
71,31,238,
72,31,238,
73,31,238,
76,31,238,
77,31,238,
78,31,238,
79,31,238,
80,31,238,
83,31,238,
84,31,238,
85,31,238,
86,31,238,
87,31,238,
90,31,17,
1,32,153,
50,32,153,
53,32,204,
54,32,204,
55,32,204,
56,32,204,
59,32,204,
60,32,204,
61,32,204,
62,32,204,
69,32,238,
73,32,238,
76,32,238,
80,32,238,
83,32,238,
87,32,238,
90,32,17,
1,33,153,
50,33,153,
53,33,204,
54,33,204,
55,33,204,
56,33,204,
57,33,204,
58,33,204,
59,33,204,
60,33,204,
61,33,204,
62,33,204,
65,33,136,
66,33,136,
69,33,238,
73,33,238,
76,33,238,
80,33,238,
83,33,238,
87,33,238,
90,33,17,
1,34,153,
50,34,153,
53,34,204,
54,34,255,
55,34,255,
56,34,204,
57,34,204,
58,34,204,
59,34,204,
60,34,204,
61,34,204,
62,34,204,
65,34,136,
66,34,136,
69,34,238,
73,34,238,
76,34,238,
80,34,238,
83,34,238,
87,34,238,
90,34,17,
1,35,153,
50,35,153,
53,35,204,
54,35,204,
55,35,255,
56,35,204,
57,35,204,
58,35,204,
59,35,204,
60,35,204,
61,35,204,
62,35,204,
69,35,238,
70,35,238,
71,35,238,
72,35,238,
73,35,238,
76,35,238,
77,35,238,
78,35,238,
79,35,238,
80,35,238,
83,35,238,
84,35,238,
85,35,238,
86,35,238,
87,35,238,
90,35,17,
1,36,153,
50,36,153,
53,36,204,
54,36,204,
55,36,204,
56,36,204,
57,36,204,
58,36,204,
59,36,204,
60,36,204,
61,36,204,
62,36,204,
69,36,238,
73,36,238,
76,36,238,
80,36,238,
83,36,238,
87,36,238,
90,36,17,
1,37,153,
50,37,153,
54,37,204,
55,37,204,
56,37,204,
57,37,204,
58,37,204,
59,37,204,
60,37,204,
61,37,204,
69,37,238,
73,37,238,
76,37,238,
80,37,238,
83,37,238,
87,37,238,
90,37,17,
1,38,153,
50,38,153,
55,38,204,
56,38,204,
57,38,204,
58,38,204,
59,38,204,
60,38,204,
65,38,136,
66,38,136,
69,38,238,
73,38,238,
76,38,238,
80,38,238,
83,38,238,
87,38,238,
90,38,17,
1,39,153,
50,39,153,
56,39,204,
57,39,204,
58,39,204,
59,39,204,
65,39,136,
66,39,136,
69,39,238,
73,39,238,
76,39,238,
80,39,238,
83,39,238,
87,39,238,
90,39,17,
1,40,153,
50,40,153,
57,40,204,
58,40,204,
69,40,238,
70,40,238,
71,40,238,
72,40,238,
73,40,238,
76,40,238,
77,40,238,
78,40,238,
79,40,238,
80,40,238,
83,40,238,
84,40,238,
85,40,238,
86,40,238,
87,40,238,
90,40,17,
1,41,153,
50,41,153,
90,41,17,
1,42,153,
50,42,153,
90,42,17,
1,43,153,
50,43,153,
52,43,170,
53,43,170,
54,43,170,
55,43,170,
56,43,170,
57,43,170,
58,43,170,
59,43,170,
60,43,170,
61,43,170,
61,43,170,
62,43,170,
63,43,170,
64,43,170,
65,43,170,
66,43,170,
67,43,170,
68,43,170,
69,43,170,
70,43,170,
71,43,170,
72,43,170,
73,43,170,
74,43,170,
75,43,170,
76,43,170,
77,43,170,
78,43,170,
79,43,170,
80,43,170,
81,43,170,
82,43,170,
83,43,170,
84,43,170,
85,43,170,
86,43,170,
87,43,170,
88,43,170,
90,43,17,
1,44,153,
50,44,153,
52,44,170,
88,44,170,
90,44,17,
1,45,153,
50,45,153,
52,45,170,
88,45,170,
90,45,17,
1,46,153,
50,46,153,
52,46,170,
88,46,170,
90,46,17,
1,47,153,
50,47,153,
52,47,170,
88,47,170,
90,47,17,
1,48,153,
50,48,153,
52,48,170,
53,48,170,
54,48,170,
55,48,170,
56,48,170,
57,48,170,
58,48,170,
59,48,170,
60,48,170,
61,48,170,
61,48,170,
62,48,170,
63,48,170,
64,48,170,
65,48,170,
66,48,170,
67,48,170,
68,48,170,
69,48,170,
70,48,170,
71,48,170,
72,48,170,
73,48,170,
74,48,170,
75,48,170,
76,48,170,
77,48,170,
78,48,170,
79,48,170,
80,48,170,
81,48,170,
82,48,170,
83,48,170,
84,48,170,
85,48,170,
86,48,170,
87,48,170,
88,48,170,
90,48,17,
1,49,153,
50,49,153,
90,49,17,
1,50,153,
2,50,153,
3,50,153,
4,50,153,
5,50,153,
6,50,153,
7,50,153,
8,50,153,
9,50,153,
10,50,153,
11,50,153,
12,50,153,
13,50,153,
14,50,153,
15,50,153,
16,50,153,
17,50,153,
18,50,153,
19,50,153,
20,50,153,
21,50,153,
22,50,153,
23,50,153,
24,50,153,
25,50,153,
26,50,153,
27,50,153,
28,50,153,
29,50,153,
30,50,153,
31,50,153,
32,50,153,
33,50,153,
34,50,153,
35,50,153,
36,50,153,
37,50,153,
38,50,153,
39,50,153,
40,50,153,
41,50,153,
42,50,153,
43,50,153,
44,50,153,
45,50,153,
46,50,153,
47,50,153,
48,50,153,
49,50,153,
50,50,17,
51,50,17,
52,50,17,
53,50,17,
54,50,17,
55,50,17,
56,50,17,
57,50,17,
58,50,17,
59,50,17,
60,50,17,
61,50,17,
62,50,17,
63,50,17,
64,50,17,
65,50,17,
66,50,17,
67,50,17,
68,50,17,
69,50,17,
70,50,17,
71,50,17,
72,50,17,
73,50,17,
74,50,17,
75,50,17,
76,50,17,
77,50,17,
78,50,17,
79,50,17,
80,50,17,
81,50,17,
82,50,17,
83,50,17,
84,50,17,
85,50,17,
86,50,17,
87,50,17,
88,50,17,
89,50,17,
90,50,17,
0,0,0,
	};

	system("cls");
	system("color 70");

	while (key != 27) {
		//置空地图；
		for (int i = 0; i < 48; i++)
			for (int j = 0; j < 48; j++) {
				map[i][j] = 0;
				draw(i + 1, j + 1, 119);
			}

		key = -1;//初始化键盘；
		on_off = 1;//模块开启；
		buff_count = 0;
		bullet = 3;
		score = 0;
		life = 3;
		//绘制地图；
		for (short i = 0; p_map[i][0] != 0; i++)
			draw(p_map[i][0] - 1, p_map[i][1] - 1, p_map[i][2]);
		//重置分数；
		scoring(p_s, score);
		scoring(p_b, bullet);
		scoring(p_l, life);
		//障碍线程；
		DWORD th_om;
		CloseHandle(CreateThread(NULL, 0, obstacle_move, NULL, 0, &th_om));
		//飞机移动；
		if (plane_move() == 1)
			break;
		//游戏结束；
		while (bf == 1 || fi == 1 || o_m == 1);
		game_over();
	}
	system("cls");
}
//墙壁移动线程；
DWORD WINAPI obstacle_move(LPVOID lpParamter) {
	o_m = 1;
	srand((unsigned)time(0));//随机种子；
	y2 = &Y2; y3 = &Y3; y4 = &Y4; y5 = &Y5;//四障碍成员；
	y2->Y = -14, y3->Y = -29, y4->Y = -44, y5->Y = 1;//初始坐标；
	y2->extend = -1, y3->extend = -1, y4->extend = -1, y5->extend = -1;//初始坐标；
	//初始信息；
	short length1 = 24, length2 = 24, length3 = 24, length4 = 24, sleep = 100;
	bool lr1 = 0, lr2 = 1, lr3 = 0, lr4 = 1;

	message("按任意键开始游戏！");
	while (1)
		if (key > 0)
			break;
	//buff生成线程；
	DWORD th_bf;
	CloseHandle(CreateThread(NULL, 0, buff, NULL, 0, &th_bf));
	//墙壁移动循环；
	while (1) {
		P(2);
		if (on_off == 0) {//用于退出线程；
			V(2);
			o_m = 0;
			return 0;
		}
		if (y5->Y > 48) {//初始每块墙信息；
			for (short i = 0; i < length1; i++)//清除首行墙；
				if (lr1 == 0) {
					P(3);
					state(i + 1, 48, 0);//坐标记录；
					V(3);

					P(1);
					draw(i + 1, 48, 119);
					V(1);
				}
				else {
					P(3);
					state(48 - i, 48, 0);
					V(3);

					P(1);
					draw(48 - i, 48, 119);
					V(1);
				}
			score++;
			P(4);
			scoring(p_s, score);
			V(4);
			y5->extend = -1;
			y5->Y = -10;
			lr1 = rand() % 2;
			length1 = 24 + rand() % 5;
		}
		if (y2->Y > 48) {
			for (short i = 0; i < length2; i++)
				if (lr2 == 0) {
					P(3);
					state(i + 1, 48, 0);
					V(3);

					P(1);
					draw(i + 1, 48, 119);
					V(1);
				}
				else {
					P(3);
					state(48 - i, 48, 0);
					V(3);

					P(1);
					draw(48 - i, 48, 119);
					V(1);
				}
			score++;
			P(4);
			scoring(p_s, score);
			V(4);
			y2->extend = -1;
			y2->Y = -10;
			lr2 = rand() % 2;
			length2 = 24 + rand() % 5;
		}
		if (y3->Y > 48) {
			for (short i = 0; i < length3; i++)
				if (lr3 == 0) {
					P(3);
					state(i + 1, 48, 0);
					V(3);

					P(1);
					draw(i + 1, 48, 119);
					V(1);
				}
				else {
					P(3);
					state(48 - i, 48, 0);
					V(3);

					P(1);
					draw(48 - i, 48, 119);
					V(1);
				}
			score++;
			P(4);
			scoring(p_s, score);
			V(4);
			y3->extend = -1;
			y3->Y = -10;
			lr3 = rand() % 2;
			length3 = 24 + rand() % 5;
		}
		if (y4->Y > 48) {
			for (short i = 0; i < length4; i++)
				if (lr4 == 0) {
					P(3);
					state(i + 1, 48, 0);
					V(3);

					P(1);
					draw(i + 1, 48, 119);
					V(1);
				}
				else {
					P(3);
					state(48 - i, 48, 0);
					V(3);

					P(1);
					draw(48 - i, 48, 119);
					V(1);
				}
			score++;
			P(4);
			scoring(p_s, score);
			V(4);
			y4->extend = -1;
			y4->Y = -10;
			lr4 = rand() % 2;
			length4 = 24 + rand() % 5;
		}
		//绘制单行墙；
		obstacle(y5, length1, lr1);
		obstacle(y2, length2, lr2);
		obstacle(y3, length3, lr3);
		obstacle(y4, length4, lr4);
		//坐标下移；
		y5->Y++;
		y2->Y++;
		y3->Y++;
		y4->Y++;
		V(2);
		if (sleep > 60) {
			sleep = 200 - score;
		}
		Sleep(sleep);
	}
}
//墙体绘制函数；
void obstacle(coordinates* y, short length, bool left_right) {
	short conut = 0;
	if (left_right == 0) {//左右；
		if (y->Y > 0)//进入可视区才可绘制；
			for (short i = 1; i <= length; i++) {
				if (y->extend == i)
					conut++;

				if (y->Y > 1) {//清除前一行；
					P(3);
					if (state(i, y->Y - 1) == 2 || state(i, y->Y - 1) == 3 || state(i, y->Y - 1) == 4) {//判断是否为buff或飞机；
						V(3);
						if (conut > 0 && conut < 6)
							conut++;
						P(3);
						if (i >= y->extend&& i < y->extend + 5) {
							V(3);
							continue;
						}
						if (crash(i, y->Y, 3) == 1)
							on_off = 0;
						V(3);
						continue;
					}
					V(3);

					P(3);
					state(i, y->Y - 1, 0);
					V(3);
					P(1);
					draw(i, y->Y - 1, 119);
					V(1);
				}
				//判断是否被击中；
				if (conut > 0 && conut < 6) {
					conut++;
					continue;
				}
				P(3);
				if (state(i, y->Y) == 2 || state(i, y->Y) == 3 || state(i, y->Y) == 4) {
					V(3);
					if (conut != 0 && conut < 6)
						conut++;
					continue;
				}
				V(3);
				//绘制墙体；
				P(3);
				state(i, y->Y, 1);
				V(3);
				P(1);
				draw(i, y->Y, 79);
				V(1);
			}
	}
	else {
		if (y->Y > 0)
			for (short i = 0; i < length; i++) {
				if (y->extend == 44 - i)
					conut++;

				if (y->Y > 1) {
					P(3);
					if (state(48 - i, y->Y - 1) == 2 || state(48 - i, y->Y - 1) == 3 || state(48 - i, y->Y - 1) == 4) {
						V(3);
						if (conut != 0 && conut < 6)
							conut++;
						P(3);
						if (48 - i >= y->extend && 48 - i < y->extend + 5) {
							V(3);
							continue;
						}
						if (crash(48 - i, y->Y, 3) == 1)
							on_off = 0;
						V(3);
						continue;
					}
					V(3);

					P(3);
					state(48 - i, y->Y - 1, 0);
					V(3);
					P(1);
					draw(48 - i, y->Y - 1, 119);
					V(1);
				}
				//判断是否被击中；
				if (conut != 0 && conut < 6) {
					conut++;
					continue;
				}
				//判断是否有障碍；
				P(3);
				if (state(48 - i, y->Y) == 2 || state(48 - i, y->Y) == 3 || state(48 - i, y->Y) == 4) {
					V(3);
					if (conut != 0 && conut < 6)
						conut++;
					continue;
				}
				V(3);
				P(3);
				state(48 - i, y->Y, 1);
				V(3);
				P(1);
				draw(48 - i, y->Y, 79);
				V(1);
			}
	}
}
//飞机移动函数；
short plane_move() {
	short plane[][3] = {
3,1,17,
2,2,17,
3,2,187,
4,2,17,
2,3,17,
3,3,187,
4,3,17,
1,4,17,
2,4,187,
3,4,187,
4,4,187,
5,4,17,
1,5,17,
2,5,187,
3,5,17,
4,5,187,
5,5,17,
1,6,17,
2,6,17,
4,6,17,
5,6,17,
1,7,17,
5,7,17,
0,0,0,
	};
	short x = 22, y = 40;//飞机初始位置；
	bool stamp = 0, over = 0;
	//开火后的子弹形成链表进行移动；
	coordinates * node = NULL;
	fire_head = (coordinates*)malloc(sizeof(coordinates));
	end = fire_head;
	end->next = NULL;
	DWORD th_fi;
	CloseHandle(CreateThread(NULL, 0, fire, NULL, 0, &th_fi));
	//绘制飞机；
	for (int i = 0; plane[i][0] != 0; i++) {
		P(1);
		draw(x + plane[i][0], y + plane[i][1], plane[i][2]);
		V(1);
	}
	//监听键盘进行移动；
	while (1) {
		if (on_off == 0)
			return 0;
		switch (key) {
		case 299://left;
			if (x < 1) break;
			x = x - 1;

			for (int i = 0; plane[i][0] != 0; i++) {
				P(3);
				state(x + 1 + plane[i][0], y + plane[i][1], 0);
				P(1);
				draw(x + 1 + plane[i][0], y + plane[i][1], 119);
				V(1);
				V(3);
			}
			
			for (int i = 0; plane[i][0] != 0; i++) {
				P(3);
				P(1);
				draw(x + plane[i][0], y + plane[i][1], plane[i][2]);
				V(1);
				crash(x + plane[i][0], y + plane[i][1], 4);
				over = crash(x + plane[i][0], y + plane[i][1], 2);
				if (over == 1)
					on_off = 0;
				state(x + plane[i][0], y + plane[i][1], 4);
				V(3);	
			}
			
			message("左");
			key = -1;
			break;
			
		case 301://right
			if (x > 42) break;
			x = x + 1;

			for (int i = 0; plane[i][0] != 0; i++) {
				P(3);
				state(x - 1 + plane[i][0], y + plane[i][1], 0);
				P(1);
				draw(x - 1 + plane[i][0], y + plane[i][1], 119);
				V(1);
				V(3);
			}
			
			for (int i = 0; plane[i][0] != 0; i++) {
				P(3);
				P(1);
				draw(x + plane[i][0], y + plane[i][1], plane[i][2]);
				V(1);
				crash(x + plane[i][0], y + plane[i][1], 4);
				over = crash(x + plane[i][0], y + plane[i][1], 2);
				if (over == 1)
					on_off = 0;
				state(x + plane[i][0], y + plane[i][1], 4);
				V(3);
			}
		
			message("右");
			key = -1;
			break;
			
		case 296://up;
			if (y < 1) break;
			y = y - 1;

			for (int i = 0; plane[i][0] != 0; i++) {
				P(3);
				state(x + plane[i][0], y + 1 + plane[i][1], 0);
				P(1);
				draw(x + plane[i][0], y + 1 + plane[i][1], 119);
				V(1);
				V(3);
			}

			for (int i = 0; plane[i][0] != 0; i++) {
				P(3);
				P(1);
				draw(x + plane[i][0], y + plane[i][1], plane[i][2]);
				V(1);
				crash(x + plane[i][0], y + plane[i][1], 4);
				over = crash(x + plane[i][0], y + plane[i][1], 2);
				if (over == 1)
					on_off = 0;
				state(x + plane[i][0], y + plane[i][1], 4);
				V(3);
			}

			message("上");
			key = -1;
			break;

		case 304://down;
			if (y > 40) break;
			y = y + 1;
			
			for (int i = 0; plane[i][0] != 0; i++) {
				P(3);
				state(x + plane[i][0], y - 1 + plane[i][1], 0);
				P(1);
				draw(x + plane[i][0], y - 1 + plane[i][1], 119);
				V(1);
				V(3);
			}
			for (int i = 0; plane[i][0] != 0; i++) {
				P(3);
				P(1);
				draw(x + plane[i][0], y + plane[i][1], plane[i][2]);
				V(1);
				crash(x + plane[i][0], y + plane[i][1], 4);
				over = crash(x + plane[i][0], y + plane[i][1], 2);
				if (over == 1)
					on_off = 0;
				state(x + plane[i][0], y + plane[i][1], 4);
				V(3);
			}

			message("下");
			key = -1;
			break;
			
		case 32://fire；
			if (bullet == 0) {
				message("当前没有子弹！", 116);
				key = -1;
				break;
			}
			node = (coordinates*)malloc(sizeof(coordinates));
			end->next = node;
			node->X = x + 3;
			node->Y = y;
			node->next = NULL;
			end = node;

			message("开火!");
			bullet--;
			scoring(p_b, bullet);
			key = -1;
			break;
		case 27://退出；
			key = -1;
			P(2);
			message("是否确定退出？", 116, 0, 1);
			while (key == -1 || key == 27 || key == 13) {
				if (key == 27 || key == 13) {
					V(2);
					on_off = 0;
					return 1;
				}
			}
			V(2);
			key = -1;
			break;
		}
	}
}
//碰撞；
bool crash(short x, short y, short type) {
	if (type == 1) {//子弹检测；
		if (state(x, y) == 1) {
			message("击毁！");
			score = score + 2;
			P(4);
			scoring(p_s, score);
			V(4);
			get_extend(x, y);
			return 1;
		}
		return 0;
	}

	if (type == 2) {//飞机―墙；
		if (time(0) - p_timestamp < 3)
			return 0;
		if (state(x, y) == 1) {
			life--;
			P(4);
			scoring(p_l, life);
			V(4);
			message("飞机受损！请远离墙体！", 116, 3);
			p_timestamp = time(0);
			if (life == 0)
				return 1;
		}
		return 0;
	}

	if (type == 3) {//墙―飞机；
		if (time(0) - p_timestamp < 3)
			return 0;
		if (state(x, y) == 4) {
			life--;
			P(4);
			scoring(p_l, life);
			V(4);
			message("飞机受损！请远离墙体！", 116, 3);
			p_timestamp = time(0);
			if (life == 0)
				return 1;
		}
		return 0;
	}

	if (type == 4) {//飞机碰撞buff；
		if (state(x, y) == 2) {
			life++;
			score += 2;
			P(4);
			scoring(p_l, life);
			scoring(p_s, score);
			V(4);
			clear_buff(x, y);
			buff_count--;
		}
		if (state(x, y) == 3) {
			bullet++;
			score++;
			P(4);
			scoring(p_b, bullet);
			scoring(p_s, score);
			V(4);
			clear_buff(x, y);
			buff_count--;
		}
		return 0;
	}

}
//获取碰撞墙壁；
void get_extend(short x, short y) {
	if (y == y5->Y - 1)
		y5->extend = x - 2;
	if (y == y2->Y - 1)
		y2->extend = x - 2;
	if (y == y3->Y - 1)
		y3->extend = x - 2;
	if (y == y4->Y - 1)
		y4->extend = x - 2;
}
//buff清理；
bool clear_buff(short x, short y) {
	x = x - 2;
	y = y - 1;
	for (int i = 0; i < 5; i++)
		for (int j = 0; j < 3; j++) {
			if (state(x + i, y + j) == 2 || state(x + i, y + j) == 3) {
				state(x + i, y + j, 0);
				if (state(x + i, y + j) != 4 && !(i == 2 && j == 1)) {
					P(1);
					draw(x + i, y + j, 119);
					V(1);
				}
			}
		}
	return 0;
}
//子弹移动线程；
DWORD WINAPI fire(LPVOID lpParamter) {
	fi = 1;
	coordinates* node, *TS;
	node = (coordinates*)malloc(sizeof(coordinates));
	TS = (coordinates*)malloc(sizeof(coordinates));//存放释放的节点；
	node = fire_head;

	while (1) {
		P(2);
		if (on_off == 0) {
			V(2);
			fi = 0;
			return 0;
		}
			
		while (node->next != NULL) {//节点个数是子弹个数；
			P(3);
			if (crash(node->next->X, node->next->Y, 1) == 1 || crash(node->next->X, node->next->Y + 1, 1) == 1 || crash(node->next->X, node->next->Y - 1, 1) == 1)
				node->next->Y = 0;//判断是否碰触；
			V(3);

			if (node->next->Y == 0) {//节点y轴为0时子弹生命结束，释放节点；
				P(1);
				draw(node->next->X, 1, 119);
				V(1);
				TS = node->next;
				node->next = TS->next;
				free(TS);
				continue;
			}
			P(3);
			if (node->next->Y != 1 && state(node->next->X, node->next->Y - 1) != 2 && state(node->next->X, node->next->Y - 1) != 3) {//子弹不得触碰buff，绘制子弹；
				V(3);
				P(1);
				draw(node->next->X, node->next->Y - 1, 34);
				V(1);
			}
			V(3);

			P(3);
			if (state(node->next->X, node->next->Y) != 2 && state(node->next->X, node->next->Y) != 3) {//子弹清理不得清理buff；
				V(3);
				P(1);
				draw(node->next->X, node->next->Y, 119);
				V(1);
			}
			V(3);
			//进行下一个节点；
			node->next->Y = node->next->Y - 1;
			node = node->next;
		}
		end = node;
		node = fire_head;
		V(2);
		Sleep(100);//子弹延迟；
	}
}
//buff生成；
DWORD WINAPI buff(LPVOID lpParamter) {
	bf = 1;
	unsigned timestamp = time(0) + 10;
	srand((unsigned)time(0));
	short x = 0, y = 0;
	short life[][3]{
		1,1,204,2,1,119,3,1,204,1,2,119,2,2,204,3,2,119,0,0,0,
	}, bullet[][3]{
		1,1,119,2,1,34,3,1,119,1,2,34,2,2,119,3,2,34,0,0,0,
	};

	while (1) {
		if (buff_count < 2) {
			while (time(0) - timestamp < 10)
				if (on_off == 0) {
					clear_buff(x, y);
					bf = 0;
					return 0;
				}
			if (rand() % 2 == 0) {
				x = rand() % 9 * 3 + 8;//buff随机位置；
				y = rand() % 9 * 3 + 8;
				P(3);
				if (state(x, y) == 2 || state(x, y) == 3 || state(x + 5, y + 5) == 2 || state(x + 5, y + 5) == 3) {//buff不得重叠；
					V(3);
					continue;
				}
				V(3);
				for (int i = 0; life[i][0] != 0; i++) {//绘制buff；
					P(3);
					state(life[i][0] + x, life[i][1] + y, 2);
					V(3);

					P(1);
					draw(life[i][0] + x, life[i][1] + y, life[i][2]);
					V(1);
				}
			}
			else {
				x = rand() % 9 * 3 + 8;
				y = rand() % 9 * 3 + 8;
				P(3);
				if (state(x, y) == 2 || state(x, y) == 3 || state(x + 2, y + 1) == 2 || state(x + 2, y + 1) == 3) {
					V(3);
					continue;
				}
				V(3);
				for (int i = 0; bullet[i][0] != 0; i++) {
					P(3);
					state(bullet[i][0] + x, bullet[i][1] + y, 3);
					V(3);

					P(1);
					draw(bullet[i][0] + x, bullet[i][1] + y, bullet[i][2]);
					V(1);
				}
			}
			buff_count++;
			timestamp = time(0);
		}
	}
}